Итоговый конспект: От простого бэктеста к профессиональной системе
Сегодня вы прошли путь от запуска простого, но убыточного бэктеста до создания полноценной, быстрой и надежной системы для поиска и проверки торговых стратегий. Этот документ — конспект вашего пути, к которому вы всегда можете вернуться.

Раздел 1: Анализ и улучшение торговой стратегии
1.1. Исходная проблема: Убытки из-за комиссий
Симптом: Самый первый бэктест показал отрицательную доходность (-19%), несмотря на приличный процент выигрышных сделок (Win Rate).

Диагноз: Главной причиной убытков оказались огромные комиссионные расходы. Стратегия совершала слишком много сделок (900+ за месяц), и затраты на них "съедали" всю потенциальную прибыль.

1.2. Решение: Фильтры и управление рисками
Чтобы бороться с избыточной торговлей и повысить качество сигналов, мы добавили в стратегию несколько уровней защиты:

Фильтры входа:

Фильтр тренда (Trend Filter): Позволяет входить в лонг только на растущем рынке и в шорт — только на падающем (на основе пересечения EMA).

Фильтр волатильности (Volatility Filter): Запрещает торговлю в периоды аномальной волатильности (на основе ATR), когда рынок слишком хаотичен.

Фильтр объема (Volume Filter): Запрещает торговлю при низких объемах, когда сигналы могут быть ложными.

Управление рисками:

Лимит сделок в день (max_trades_per_day): Прямое ограничение для борьбы с комиссиями.

Стоп по просадке (max_drawdown_stop): Защитный механизм, который останавливает торговлю, если потери капитала достигают критического уровня.

Раздел 2: Оптимизация производительности ("Ускорители")
2.1. Проблема: Медленное выполнение
Симптом: Процесс оптимизации на мощном Mac M3 Pro был очень медленным (например, 43 теста за 3 часа).

Диагноз: По умолчанию Python-скрипт использовал только одно ядро процессора, в то время как остальные простаивали.

2.2. Решение №1: Параллельные вычисления (n_jobs)
Метод: Мы добавили параметр n_jobs=-1 в функцию study.optimize() библиотеки Optuna.

Результат: Это заставило скрипт использовать все 12 ядер процессора одновременно, запуская по 12 бэктестов параллельно.

2.3. Решение №2 и "Бутылочное горлышко" GPU
Симптом: После включения n_jobs мы обнаружили, что принудительный перевод всех вычислений на CPU (вместо GPU) дал невероятное ускорение в 62 раза.

Диагноз: Возникло "бутылочное горлышко" (bottleneck). 12 параллельных процессов пытались одновременно получить доступ к одному общему ресурсу — видеокарте (GPU). Затраты на координацию этой очереди оказались выше, чем польза от скорости GPU.

Вывод: Для задач, состоящих из множества коротких, независимых вычислений, использование всех ядер CPU в параллельном режиме может быть значительно эффективнее, чем попытка использовать GPU.

2.4. Нагрев процессора
Вопрос: Нормально ли, что процессор сильно греется при 12 работающих ядрах?

Ответ: Да, это абсолютно нормально. Важно различать:

Количество тепла: Значительно возрастает, так как все ядра выделяют энергию.

Температура: Растет не пропорционально, а до нового, более высокого, но стабильного и безопасного уровня (например, с 65°C до 85-95°C), так как система охлаждения начинает работать активнее, чтобы рассеивать возросшее количество тепла.

Раздел 3: Методология поиска и верификации ("Способы тренировки")
3.1. Главный риск: Переобучение (Overfitting)
Определение: Это ситуация, когда алгоритм не "учится" общему принципу, а просто "запоминает" исторические данные. Он находит идеальные параметры для прошлого, но проваливается в будущем, так как рынок постоянно меняется.

Как распознать: Классический признак — невероятно хорошие результаты на бэктесте (огромная прибыль, минимальная просадка), которые выглядят "слишком хорошо, чтобы быть правдой".

3.2. Ключевой индикатор: Коэффициент Шарпа (Sharpe Ratio)
Что это: Показатель "качества" и "стабильности" прибыли. Он отвечает на вопрос: "Какую доходность я получаю на единицу риска?". Хорошим считается значение > 1.0, отличным > 2.0.

Как использовать: Вы получили результат +480% прибыли с просадкой всего -5%, но при этом Sharpe Ratio был всего 0.51. Это огромное противоречие и главный красный флаг, указывающий на то, что прибыль была крайне нестабильной и, скорее всего, является результатом переобучения.

3.3. Решение: Профессиональный воркфлоу (Train/Validate/Test)
Это самый надежный способ борьбы с переобучением. Вся доступная история делится на 3 части:

Тренировочный набор (Training Set, ~70% данных): На этом "старом" наборе данных проводится основная, массивная оптимизация (например, 1000+ тестов) для поиска нескольких лучших "кандидатов".

Валидационный набор (Validation Set, ~15% данных): Лучшие кандидаты с первого этапа проходят "проверку" на этом наборе данных, который они еще не видели. Тот, кто покажет лучший результат здесь, становится "чемпионом".

Тестовый набор (Test Set, ~15% данных): "Чемпион" проходит финальный "экзамен" на самых свежих данных. Результат этого теста — самая честная оценка того, как стратегия могла бы работать в реальных условиях.

3.4. Проблема невоспроизводимости результатов
Симптом: При переходе от медленного режима (n_jobs=1) к быстрому (n_jobs=-1) лучшие результаты Optuna изменились.

Причина: Optuna — адаптивный алгоритм. Параметры для следующих тестов зависят от результатов предыдущих. В последовательном режиме она идет по одному "пути". В параллельном режиме тесты завершаются в непредсказуемом порядке, и Optuna идет по совершенно другому "пути" исследования.

Раздел 4: Эффективность поиска и досрочное завершение тестов
4.1. Наблюдение: "Странная" скорость
Вы заметили, что даже на большом объеме данных (365 дней) некоторые тесты завершаются очень быстро (за несколько секунд), в то время как другие занимают несколько минут. При этом быстрые тесты могут показывать небольшой положительный результат, а не только провальный -99999.

4.2. Объяснение: Система умного "отсева"
Это не ошибка, а ожидаемое и правильное поведение системы. Оно означает, что ваш процесс оптимизации эффективно отбраковывает нежизнеспособные стратегии, не тратя время на их полный прогон.

4.3. Механизм досрочного завершения
Есть два уровня "отсева", которые могут остановить тест до того, как он обработает все данные:

Уровень 1: Внутри стратегии (Risk Management)
Этот механизм срабатывает прямо во время симуляции. Если стратегия нарушает одно из правил управления рисками, бэктест для нее немедленно прекращается.

Код, отвечающий за это (в check_risk_management):

    def check_risk_management(self):
        # ...
        # Проверка максимальной просадки от пикового значения
        self.peak_equity = max(self.peak_equity, self.equity)
        current_drawdown = (self.peak_equity - self.equity) / self.peak_equity
        if current_drawdown > self.max_drawdown_stop:
            if self.position:
                self.position.close()
            # Возвращает False, что останавливает дальнейшие действия в методе next()
            # и может привести к досрочному завершению, если логика это предусматривает
            return False 
        # ...
        return True

Пример: Optuna задает max_drawdown_stop: 0.1 (10%). Стратегия начинает торговать, зарабатывает, ее пиковый баланс достигает $11,000. Затем она начинает терять, и ее баланс опускается до $9,899. Просадка от пика составила (11000 - 9899) / 11000 = 10.009%. Это больше лимита. Бэктест останавливается. Итоговый результат может быть даже слегка отрицательным, но не катастрофическим. Тест занял 15 секунд вместо 3 минут.

Уровень 2: Внутри Optuna (Штрафы)
Этот механизм срабатывает после завершения бэктеста (даже если он был досрочным). Optuna анализирует итоговую статистику.

Код, отвечающий за это (в objective):

def objective(trial, data, ...):
    # ...
    try:
        # ... запускается бэктест ...
        stats = bt.run()
        
        num_trades = stats.get('# Trades', 0)
        return_pct = stats.get('Return [%]', -999)
        max_drawdown = abs(stats.get('Max. Drawdown [%]', 100))
        
        # Правила "штрафного балла"
        if num_trades < 10 or return_pct < -50 or max_drawdown > 50:
            return -99999 # Присваиваем ужасную оценку и не считаем дальше
            
        # ... расчет нормальной оценки ...
    except Exception:
        return -99999 # То же самое, если тест вообще "сломался"

Пример: Стратегия дожила до конца, но совершила всего 8 сделок. Это статистически незначимо. Optuna, видя num_trades < 10, немедленно присваивает этому тесту оценку -99999 и переходит к следующему.

Вывод: Ваша система эффективно ищет только настоящих "марафонцев" — стратегии, которые не только прибыльны, но и способны выжить на всей длинной и сложной дистанции.